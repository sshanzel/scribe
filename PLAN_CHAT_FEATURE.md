# Chat Feature Implementation Plan

A contact-aware AI chat interface that allows users to ask questions about contacts and get answers based on meeting history and CRM data.

## Overview

- **UI**: Floating bubble on bottom right, always accessible
- **Core Flow**: User tags a contact (required) → AI answers using meetings + CRM data → Response includes meeting links
- **Scope**: Thread-based, private per user

---

## V1 Decisions

| Decision | Choice |
|----------|--------|
| Contact tagging | **Required** for v1 (stored in message metadata) |
| Thread messages in AI context | **Yes** - include all messages from current thread |
| Cross-thread context | **No** - threads are isolated from each other |
| Message storage | **Yes** - store all for history/display |
| Content format | **Plain text + metadata** |
| Background sync | **No** |
| Meeting context | **Last 10 meetings** with contact |
| Gemini API format | **Multi-turn array** (not concatenated prompt) |

---

## Why Contacts Are Essential

The contacts table provides a **unique identifier** (email address) that ensures accurate meeting retrieval. Without it, name-based matching would be unreliable and could cause the AI to hallucinate.

**Problem without contacts table:**
```
User asks: "What did John say about pricing?"
                    ↓
Search by name: WHERE participant.name ILIKE '%John%'
                    ↓
Returns meetings for:
  - John Doe (john.doe@company.com)     ← User meant this one
  - John Smith (john.smith@other.com)   ← Wrong person!
  - Johnny Appleseed (johnny@fruit.com) ← Wrong person!
                    ↓
AI sees mixed transcripts → Could hallucinate or give wrong answers
```

**Solution with contacts table:**
```
User clicks "@John Doe" in dropdown
                    ↓
Selects contact with id=123, email=john.doe@company.com
                    ↓
metadata = { "mentions": [{ "contact_id": 123, ... }] }
                    ↓
ChatAI.find_meetings_for_contact uses contact_id in query:
  Meeting → CalendarEvent → CalendarEventAttendee WHERE contact_id = 123
                    ↓
Returns ONLY meetings where john.doe@company.com was an attendee
                    ↓
AI sees correct transcripts → Accurate answers
```

**Meeting Isolation Between Users:**
- User A and User B may both have meetings with the same contact (e.g., john@example.com)
- Each user should ONLY see their own meetings with that contact
- The query filters by `calendar_event.user_id` to ensure isolation
- Test coverage: `test "both users see only their own meetings with shared contact"`

---

## Phase 1: Database Schema

### 1.1 Contacts Table (Global, Normalized)

Contacts are global (one per email) and linked to users through calendar events.

```elixir
# contacts (shared, no user_id)
- id
- email (unique)
- name
- inserted_at, updated_at

# calendar_event_attendees (join table)
- id
- calendar_event_id (belongs_to calendar_events)
- contact_id (belongs_to contacts)
- display_name (name from this specific invite)
- response_status (accepted, declined, tentative)
- is_organizer (boolean)
- inserted_at
```

**Why Global Contacts:**
- Single source of truth per email address
- No duplicate contact records across users
- Users see only contacts from their calendar events (via join)

**Contact Creation:**
- Contacts are auto-created during calendar sync (from attendees)
- `CalendarSyncronizer` creates attendee records linking contacts to events

### 1.2 Chat Threads Table

```elixir
# chat_threads
- id
- user_id (belongs_to users)
- title (generated by Gemini after first interaction)
- inserted_at, updated_at
```

Note: No `contact_id` - the tagged contact is stored in message metadata. This allows future support for multi-contact mentions.

### 1.3 Chat Messages Table

```elixir
# chat_messages
- id
- thread_id (belongs_to chat_threads)
- role (user, assistant)
- content (text - plain text, human readable)
- metadata (map - stores mentions, meeting_refs, tokens_used, etc.)
- inserted_at, updated_at
```

**Content Storage (Option A - Plain text + metadata):**
```elixir
# User message example
%{
  content: "What did @John Doe say about the Q1 budget?",
  metadata: %{
    mentions: [%{contact_id: 123, name: "John Doe", start: 9, end: 18}]
  }
}

# Assistant message example
%{
  content: "In the Q1 Planning meeting on Jan 15, John mentioned...",
  metadata: %{
    meeting_refs: [%{meeting_id: 456, title: "Q1 Planning", date: "2025-01-15"}],
    tokens_used: 1250
  }
}
```

The `start` and `end` positions allow rendering mentions with styling/icons in the UI.
```

---

## Phase 2: Calendar Attendees as Join Table

Attendees are stored in a normalized join table, not JSON.

### 2.1 Schema (Implemented)

```elixir
# calendar_event_attendees
- id
- calendar_event_id (FK to calendar_events)
- contact_id (FK to contacts)
- display_name
- response_status
- is_organizer
- inserted_at
```

### 2.2 Sync Update

`CalendarSyncronizer` extracts attendees and creates records:

```elixir
defp sync_items(items, user_id, credential_id) do
  Enum.each(items, fn item ->
    {event_attrs, attendees} = parse_google_event(item, user_id, credential_id)

    case Calendar.create_or_update_calendar_event(event_attrs) do
      {:ok, calendar_event} ->
        # Create attendee records linking contacts to this event
        Contacts.create_attendees_from_event_data(calendar_event.id, attendees)
      {:error, reason} ->
        Logger.warning("Failed to create/update event: #{inspect(reason)}")
    end
  end)
end
```

### 2.3 Auto-Create Contacts

When calendar syncs, contacts are created/linked automatically:

```elixir
def create_attendees_from_event_data(calendar_event_id, attendees) do
  attendees
  |> Enum.filter(fn a -> a["email"] != nil && a["email"] != "" end)
  |> Enum.map(fn attendee ->
    email = attendee["email"]
    display_name = attendee["displayName"]

    with {:ok, contact} <- find_or_create_contact(%{email: email, name: display_name}),
         {:ok, attendee_record} <- create_calendar_event_attendee(%{
           calendar_event_id: calendar_event_id,
           contact_id: contact.id,
           display_name: display_name,
           response_status: attendee["responseStatus"],
           is_organizer: attendee["organizer"] == true
         }) do
      attendee_record
    end
  end)
end
```

---

## Phase 3: Contacts Module

### 3.1 Contact Management (Updated for Global Contacts)

```elixir
SocialScribe.Contacts
- create_contact(attrs)                    # Create global contact (no user)
- update_contact(contact, attrs)           # Update contact
- delete_contact(contact)                  # Delete contact
- find_or_create_contact(attrs)            # Find by email or create new
- list_contacts(user)                      # Contacts visible via user's calendar events
- search_contacts(user, query)             # Search contacts in user's events
- get_contact!(id)                         # Get single contact
- get_contact(id)                          # Get or nil
- get_contact_by_email(email)              # Find by email (global)
- create_calendar_event_attendee(attrs)    # Link contact to calendar event
- create_attendees_from_event_data(event_id, attendees)  # Bulk create from sync
```

**Key Change:** Contacts are global (no user_id). Users see contacts through their calendar events.

---

## Phase 4: Chat Context Module

### 4.1 Thread Management

```elixir
SocialScribe.Chat
- create_thread(user, attrs)         # attrs: %{title: optional}
- list_threads(user)                 # List user's threads
- get_thread!(id)                    # Get thread with preloads
- get_thread_for_user!(user, id)     # Get thread with ownership check
- delete_thread(thread)              # Delete thread and messages
```

### 4.2 Message Management

```elixir
SocialScribe.Chat
- create_message(thread, attrs)      # attrs: %{role, content, metadata}
- list_messages(thread)              # Get all messages in thread
- get_message!(id)                   # Get single message
```

---

## Phase 5: AI Chat Integration

### 5.1 Contact Resolution from Metadata

When user sends a message:
1. Parse metadata.mentions to get contact_id
2. Fetch contact record
3. Use contact.email to match meeting participants
4. Fetch CRM data for contact

```elixir
def resolve_contact_from_message(message) do
  case message.metadata["mentions"] do
    [%{"contact_id" => id} | _] -> Contacts.get_contact!(id)
    _ -> nil
  end
end
```

### 5.2 Context Gathering

```elixir
defp gather_contact_context(contact, user) do
  # Fetch fresh CRM data for this contact by email
  # Try HubSpot first, then Salesforce
  # Return: name, email, company, title, phone, etc.
end

defp gather_meeting_context(user, contact) do
  # Find meetings where contact participated
  # Match by: calendar_event.attendees containing contact.email
  # OR meeting_participants.name matching contact.name
  # Limit to last 10 meetings, ordered by date desc
  # Include: id, title, date, duration, transcript
end
```

### 5.3 Gemini Multi-Turn Format

Pass thread messages as array with roles (not concatenated in prompt):

```elixir
def build_gemini_payload(system_context, thread_messages, current_question) do
  # System context as first message
  contents = [
    %{role: "user", parts: [%{text: system_context}]},
    %{role: "model", parts: [%{text: "I understand. I'll answer questions based only on the provided context."}]}
  ]

  # Add thread history
  thread_contents = Enum.map(thread_messages, fn msg ->
    role = if msg.role == "user", do: "user", else: "model"
    %{role: role, parts: [%{text: msg.content}]}
  end)

  # Add current question
  current = %{role: "user", parts: [%{text: current_question}]}

  %{contents: contents ++ thread_contents ++ [current]}
end
```

### 5.4 System Context Template

```
You are a helpful assistant that answers questions about business contacts based on meeting history and CRM data.

RULES:
- Be concise and direct
- Base your answers ONLY on the context provided below
- If information is not in the meeting transcripts or contact data, clearly state that you don't have that information
- Never guess, infer, or make up information
- When referencing a meeting, use this exact format: [Meeting: {title} ({date})]({meeting_id})
- Format responses in markdown

CONTACT INFORMATION:
Name: {name}
Email: {email}
Company: {company}
Title: {title}
Phone: {phone}

MEETING HISTORY (most recent first, last 10 meetings):
{meetings_with_transcripts}
```

### 5.5 Response Generator

```elixir
SocialScribe.ChatAI
- generate_response(thread, user_message, metadata)
  # 1. Resolve contact from metadata.mentions
  # 2. Gather CRM data for contact
  # 3. Gather last 10 meetings with contact
  # 4. Get all previous messages in thread
  # 5. Build Gemini payload (multi-turn format)
  # 6. Call Gemini API
  # 7. Parse response, extract meeting references
  # 8. Save user message with metadata
  # 9. Save assistant message with metadata
  # 10. If first message in thread, generate title via Gemini
  # 11. Return response

- generate_thread_title(thread, first_message, first_response)
  # Ask Gemini to generate a short, descriptive title
  # based on the first question and answer
  # Update thread.title
```

---

## Phase 6: LiveView UI Components

### 6.1 Chat Bubble Component

```elixir
SocialScribeWeb.ChatLive.BubbleComponent
- Floating button (bottom right corner)
- Click to expand/collapse chat panel
- Optional: Badge showing thread count
```

### 6.2 Chat Panel Component

```elixir
SocialScribeWeb.ChatLive.PanelComponent
- Thread list sidebar (left side, collapsible)
- New thread button
- Active thread messages (right side)
- Message input at bottom with @mention support
```

### 6.3 Contact Mention Component

```elixir
SocialScribeWeb.ChatLive.MentionComponent
- Triggered by @ in input field
- Dropdown with contact search (searches Contacts.search_contacts)
- Shows: name, email
- Keyboard navigation (up/down/enter)
- On select: stores contact in message metadata
```

### 6.4 Message Component

```elixir
SocialScribeWeb.ChatLive.MessageComponent
- User messages: right aligned, blue background
- Assistant messages: left aligned, gray background, markdown rendered
- Meeting links: rendered from metadata.meeting_refs, clickable → /dashboard/meetings/:id
- Timestamp below each message
```

---

## Phase 7: Implementation Order

> **Note:** Each step includes test coverage. Tests are written alongside implementation, not deferred.

### Step 1: Calendar Attendees Extraction
- [x] Add `attendees` field migration to calendar_events
- [x] Update CalendarEvent schema
- [x] Update CalendarSyncronizer.parse_google_event/3 to extract attendees
- [x] **Tests:**
  - [x] CalendarEvent changeset tests for attendees field
  - [x] CalendarSyncronizer tests for attendee extraction
  - [x] Integration test with mock Google Calendar response

### Step 2: Database & Schemas
- [x] Create contacts migration (lean: id, user_id, name, email)
- [x] Create chat_threads migration (no contact_id)
- [x] Create chat_messages migration
- [x] Create Ecto schemas with changesets
- [x] **Tests:**
  - [x] Contact changeset tests (validation, unique constraint)
  - [x] ChatThread changeset tests
  - [x] ChatMessage changeset tests (role, content, metadata)

### Step 3: Contacts Context
- [x] Create Contacts context module
- [x] Implement CRUD operations
- [x] Implement search_contacts for autocomplete
- [x] Implement get_contact_by_email for deduplication
- [x] Add auto-create contacts from meeting attendees
- [x] **Tests:**
  - [x] CRUD operation tests
  - [x] search_contacts tests (partial match, case insensitive)
  - [x] get_contact_by_email tests
  - [x] Auto-create from attendees tests (new contact, existing contact)

### Step 4: Chat Context
- [x] Create Chat context module
- [x] Implement thread CRUD
- [x] Implement message CRUD with metadata
- [x] Add authorization (users own their threads)
- [x] **Tests:**
  - [x] Thread CRUD tests
  - [x] Message CRUD tests with metadata
  - [x] Authorization tests (user can only access own threads)
  - [x] Cascade delete tests (thread deletion removes messages)

### Step 5: AI Integration
- [x] Create ChatAI module
- [x] Implement contact resolution from message metadata
- [x] Implement contact CRM data fetching
- [x] Implement meeting context gathering (last 10, match by email)
- [x] Implement Gemini multi-turn payload builder
- [x] Implement generate_response
- [x] Implement generate_thread_title
- [x] **Tests:**
  - [x] Contact resolution from metadata tests
  - [x] Meeting context gathering tests (email match, limit 10, ordering)
  - [x] Gemini payload builder tests (multi-turn format)
  - [x] generate_response tests with mocked Gemini API
  - [x] generate_thread_title tests

### Step 6: Basic UI
- [x] Create chat bubble component
- [x] Create chat panel layout
- [x] Create thread list view
- [x] Create message list view
- [x] Create message input with @mention detection
- [x] Wire up to Chat context
- [x] **Tests:**
  - [x] LiveView mount tests
  - [x] Thread list rendering tests
  - [x] Message list rendering tests
  - [x] Send message event tests

### Step 7: Contact Mention UX
- [x] Create mention dropdown component
- [x] Wire up search to Contacts.search_contacts
- [x] Handle contact selection → store in metadata
- [ ] Add keyboard navigation (deferred)
- [x] **Tests:**
  - [x] Mention trigger tests (@ detection)
  - [x] Dropdown search tests
  - [x] Contact selection tests (metadata populated correctly)
  - [ ] Keyboard navigation tests (deferred)

### Step 8: Polish & Integration Testing
- [x] Add loading states (typing indicator)
- [x] Add error handling (API failures, no meetings found)
- [x] **Tests:**
  - [x] Error state rendering tests
  - [x] Loading state tests
  - [ ] End-to-end flow tests (deferred - requires more complex test setup)

---

## Data Flow

```
User creates new thread
         │
         ▼
┌─────────────────────────────────┐
│  Empty thread created           │
│  User types message with @John  │
└─────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│  @ triggers contact dropdown    │
│  User selects "John Doe"        │
│  Contact stored in metadata     │
└─────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│  User clicks Send               │
│  Resolve contact from metadata  │
└─────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│  Gather context:                │
│  - Fresh CRM data for contact   │
│  - Last 10 meetings w/ contact  │
│  - All messages in this thread  │
└─────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│  Build Gemini multi-turn payload│
│  Call Gemini API                │
└─────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│  Save user message + metadata   │
│  Save assistant message +       │
│  meeting_refs in metadata       │
└─────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│  Display in chat UI             │
│  Meeting refs → clickable links │
└─────────────────────────────────┘
```

---

## Meeting Matching Strategy

Match meetings to a contact using the calendar_event_attendees join table:

```elixir
def find_meetings_for_contact(user, %Contact{id: contact_id}) do
  # Uses contact_id (not name!) to ensure accurate matching
  # Filters by user_id to ensure meeting isolation between users

  from(m in Meeting,
    join: ce in assoc(m, :calendar_event),
    join: cea in CalendarEventAttendee, on: cea.calendar_event_id == ce.id,
    where: ce.user_id == ^user.id,           # User's meetings only
    where: cea.contact_id == ^contact_id,    # This specific contact
    order_by: [desc: m.recorded_at],
    limit: 10,
    preload: [:meeting_transcript, :meeting_participants, :calendar_event]
  )
  |> Repo.all()
end
```

**Key Design Decisions:**
1. **Uses `contact_id`, not name** - Avoids "two Johns" problem
2. **Filters by `user_id`** - User A can't see User B's meetings with same contact
3. **Join through attendees** - Only returns meetings where contact was actually present

---

## Technical Considerations

### Token Limits
- Gemini has context limits (~128k tokens for gemini-2.0-flash)
- Context includes: system prompt + CRM data + 10 meetings + thread messages
- Thread messages are typically small compared to meeting transcripts
- Strategy: If total context exceeds limit, truncate older meeting transcripts first

### Performance
- Contact search should be fast (indexed on user_id, email, name)
- CRM data fetch is external API call - show loading state
- Consider caching CRM data briefly (5 min TTL)

### Privacy
- Threads are strictly private per user
- No sharing functionality
- Ownership check on all thread/message operations

---

## Open Questions (Resolved)

| Question | Decision |
|----------|----------|
| Thread title generation | Gemini generates title after first interaction |
| Message editing | Not for v1 |
| Thread archiving | Simple delete for v1 |
| Offline handling | Show error, allow retry |
| Rate limiting | Not for v1 |

---

## Future Enhancements

See also: `IMPROVEMENTS.md`

1. **Vector embeddings** - Semantic search across all meetings instead of last 10
2. **CRM IDs in contacts** - Store salesforce_id, hubspot_id for direct linking
3. **Background contact sync** - Periodic sync from CRMs
4. **Multi-contact threads** - Ask about multiple people in one thread
5. **Suggested questions** - AI suggests follow-up questions
6. **Chat history search** - Search across all threads
7. **Export chat** - Download conversation as PDF/markdown
