# Chat Feature Implementation Plan

A contact-aware AI chat interface that allows users to ask questions about contacts and get answers based on meeting history and CRM data.

## Overview

- **UI**: Floating bubble on bottom right, always accessible
- **Core Flow**: User tags a contact (required) → AI answers using meetings + CRM data → Response includes meeting links
- **Scope**: Thread-based, private per user

---

## V1 Decisions

| Decision | Choice |
|----------|--------|
| Contact tagging | **Required** for v1 (stored in message metadata) |
| Thread messages in AI context | **Yes** - include all messages from current thread |
| Cross-thread context | **No** - threads are isolated from each other |
| Message storage | **Yes** - store all for history/display |
| Content format | **Plain text + metadata** |
| Background sync | **No** |
| Meeting context | **Last 10 meetings** with contact |
| Gemini API format | **Multi-turn array** (not concatenated prompt) |

---

## Phase 1: Database Schema

### 1.1 Contacts Table (Lean)

Minimal table for tagging/autocomplete. A contact must always exist here to be tagged.

```elixir
# contacts
- id
- user_id (belongs_to users)
- name
- email
- inserted_at, updated_at

# Unique constraint: user_id + email
```

**Contact Creation:**
- Contacts are auto-created when a meeting is created (from calendar attendees)
- User can also manually add contacts

### 1.2 Chat Threads Table

```elixir
# chat_threads
- id
- user_id (belongs_to users)
- title (generated by Gemini after first interaction)
- inserted_at, updated_at
```

Note: No `contact_id` - the tagged contact is stored in message metadata. This allows future support for multi-contact mentions.

### 1.3 Chat Messages Table

```elixir
# chat_messages
- id
- thread_id (belongs_to chat_threads)
- role (user, assistant)
- content (text - plain text, human readable)
- metadata (map - stores mentions, meeting_refs, tokens_used, etc.)
- inserted_at, updated_at
```

**Content Storage (Option A - Plain text + metadata):**
```elixir
# User message example
%{
  content: "What did @John Doe say about the Q1 budget?",
  metadata: %{
    mentions: [%{contact_id: 123, name: "John Doe", start: 9, end: 18}]
  }
}

# Assistant message example
%{
  content: "In the Q1 Planning meeting on Jan 15, John mentioned...",
  metadata: %{
    meeting_refs: [%{meeting_id: 456, title: "Q1 Planning", date: "2025-01-15"}],
    tokens_used: 1250
  }
}
```

The `start` and `end` positions allow rendering mentions with styling/icons in the UI.
```

---

## Phase 2: Calendar Attendees Extraction

Extract attendee emails from Google Calendar for accurate contact matching.

### 2.1 Schema Update

```elixir
# calendar_events (add field)
- attendees (map/jsonb) - stores array of attendee objects
```

### 2.2 Sync Update

Update `CalendarSyncronizer.parse_google_event/3` to extract:
```elixir
%{
  # ... existing fields ...
  attendees: [
    %{email: "john@example.com", name: "John Doe", response_status: "accepted"},
    %{email: "jane@example.com", name: "Jane Smith", response_status: "tentative"}
  ]
}
```

### 2.3 Auto-Create Contacts

When a meeting is created:
1. Get calendar_event.attendees
2. For each attendee with email:
   - Find or create contact with that email
   - Update name if provided

```elixir
def create_contacts_from_attendees(user, attendees) do
  Enum.each(attendees, fn attendee ->
    case get_contact_by_email(user, attendee.email) do
      nil -> create_contact(user, %{name: attendee.name, email: attendee.email})
      contact -> contact  # Already exists
    end
  end)
end
```

---

## Phase 3: Contacts Module

### 3.1 Contact Management

```elixir
SocialScribe.Contacts
- create_contact(user, attrs)        # Create new contact
- update_contact(contact, attrs)     # Update contact
- delete_contact(contact)            # Delete contact
- list_contacts(user)                # List all user's contacts
- search_contacts(user, query)       # Search by name/email for autocomplete
- get_contact!(id)                   # Get single contact
- get_contact_by_email(user, email)  # Find by email (for deduplication)
```

---

## Phase 4: Chat Context Module

### 4.1 Thread Management

```elixir
SocialScribe.Chat
- create_thread(user, attrs)         # attrs: %{title: optional}
- list_threads(user)                 # List user's threads
- get_thread!(id)                    # Get thread with preloads
- get_thread_for_user!(user, id)     # Get thread with ownership check
- delete_thread(thread)              # Delete thread and messages
```

### 4.2 Message Management

```elixir
SocialScribe.Chat
- create_message(thread, attrs)      # attrs: %{role, content, metadata}
- list_messages(thread)              # Get all messages in thread
- get_message!(id)                   # Get single message
```

---

## Phase 5: AI Chat Integration

### 5.1 Contact Resolution from Metadata

When user sends a message:
1. Parse metadata.mentions to get contact_id
2. Fetch contact record
3. Use contact.email to match meeting participants
4. Fetch CRM data for contact

```elixir
def resolve_contact_from_message(message) do
  case message.metadata["mentions"] do
    [%{"contact_id" => id} | _] -> Contacts.get_contact!(id)
    _ -> nil
  end
end
```

### 5.2 Context Gathering

```elixir
defp gather_contact_context(contact, user) do
  # Fetch fresh CRM data for this contact by email
  # Try HubSpot first, then Salesforce
  # Return: name, email, company, title, phone, etc.
end

defp gather_meeting_context(user, contact) do
  # Find meetings where contact participated
  # Match by: calendar_event.attendees containing contact.email
  # OR meeting_participants.name matching contact.name
  # Limit to last 10 meetings, ordered by date desc
  # Include: id, title, date, duration, transcript
end
```

### 5.3 Gemini Multi-Turn Format

Pass thread messages as array with roles (not concatenated in prompt):

```elixir
def build_gemini_payload(system_context, thread_messages, current_question) do
  # System context as first message
  contents = [
    %{role: "user", parts: [%{text: system_context}]},
    %{role: "model", parts: [%{text: "I understand. I'll answer questions based only on the provided context."}]}
  ]

  # Add thread history
  thread_contents = Enum.map(thread_messages, fn msg ->
    role = if msg.role == "user", do: "user", else: "model"
    %{role: role, parts: [%{text: msg.content}]}
  end)

  # Add current question
  current = %{role: "user", parts: [%{text: current_question}]}

  %{contents: contents ++ thread_contents ++ [current]}
end
```

### 5.4 System Context Template

```
You are a helpful assistant that answers questions about business contacts based on meeting history and CRM data.

RULES:
- Be concise and direct
- Base your answers ONLY on the context provided below
- If information is not in the meeting transcripts or contact data, clearly state that you don't have that information
- Never guess, infer, or make up information
- When referencing a meeting, use this exact format: [Meeting: {title} ({date})]({meeting_id})
- Format responses in markdown

CONTACT INFORMATION:
Name: {name}
Email: {email}
Company: {company}
Title: {title}
Phone: {phone}

MEETING HISTORY (most recent first, last 10 meetings):
{meetings_with_transcripts}
```

### 5.5 Response Generator

```elixir
SocialScribe.ChatAI
- generate_response(thread, user_message, metadata)
  # 1. Resolve contact from metadata.mentions
  # 2. Gather CRM data for contact
  # 3. Gather last 10 meetings with contact
  # 4. Get all previous messages in thread
  # 5. Build Gemini payload (multi-turn format)
  # 6. Call Gemini API
  # 7. Parse response, extract meeting references
  # 8. Save user message with metadata
  # 9. Save assistant message with metadata
  # 10. If first message in thread, generate title via Gemini
  # 11. Return response

- generate_thread_title(thread, first_message, first_response)
  # Ask Gemini to generate a short, descriptive title
  # based on the first question and answer
  # Update thread.title
```

---

## Phase 6: LiveView UI Components

### 6.1 Chat Bubble Component

```elixir
SocialScribeWeb.ChatLive.BubbleComponent
- Floating button (bottom right corner)
- Click to expand/collapse chat panel
- Optional: Badge showing thread count
```

### 6.2 Chat Panel Component

```elixir
SocialScribeWeb.ChatLive.PanelComponent
- Thread list sidebar (left side, collapsible)
- New thread button
- Active thread messages (right side)
- Message input at bottom with @mention support
```

### 6.3 Contact Mention Component

```elixir
SocialScribeWeb.ChatLive.MentionComponent
- Triggered by @ in input field
- Dropdown with contact search (searches Contacts.search_contacts)
- Shows: name, email
- Keyboard navigation (up/down/enter)
- On select: stores contact in message metadata
```

### 6.4 Message Component

```elixir
SocialScribeWeb.ChatLive.MessageComponent
- User messages: right aligned, blue background
- Assistant messages: left aligned, gray background, markdown rendered
- Meeting links: rendered from metadata.meeting_refs, clickable → /dashboard/meetings/:id
- Timestamp below each message
```

---

## Phase 7: Implementation Order

> **Note:** Each step includes test coverage. Tests are written alongside implementation, not deferred.

### Step 1: Calendar Attendees Extraction
- [x] Add `attendees` field migration to calendar_events
- [x] Update CalendarEvent schema
- [x] Update CalendarSyncronizer.parse_google_event/3 to extract attendees
- [x] **Tests:**
  - [x] CalendarEvent changeset tests for attendees field
  - [x] CalendarSyncronizer tests for attendee extraction
  - [x] Integration test with mock Google Calendar response

### Step 2: Database & Schemas
- [x] Create contacts migration (lean: id, user_id, name, email)
- [x] Create chat_threads migration (no contact_id)
- [x] Create chat_messages migration
- [x] Create Ecto schemas with changesets
- [x] **Tests:**
  - [x] Contact changeset tests (validation, unique constraint)
  - [x] ChatThread changeset tests
  - [x] ChatMessage changeset tests (role, content, metadata)

### Step 3: Contacts Context
- [x] Create Contacts context module
- [x] Implement CRUD operations
- [x] Implement search_contacts for autocomplete
- [x] Implement get_contact_by_email for deduplication
- [x] Add auto-create contacts from meeting attendees
- [x] **Tests:**
  - [x] CRUD operation tests
  - [x] search_contacts tests (partial match, case insensitive)
  - [x] get_contact_by_email tests
  - [x] Auto-create from attendees tests (new contact, existing contact)

### Step 4: Chat Context
- [x] Create Chat context module
- [x] Implement thread CRUD
- [x] Implement message CRUD with metadata
- [x] Add authorization (users own their threads)
- [x] **Tests:**
  - [x] Thread CRUD tests
  - [x] Message CRUD tests with metadata
  - [x] Authorization tests (user can only access own threads)
  - [x] Cascade delete tests (thread deletion removes messages)

### Step 5: AI Integration
- [ ] Create ChatAI module
- [ ] Implement contact resolution from message metadata
- [ ] Implement contact CRM data fetching
- [ ] Implement meeting context gathering (last 10, match by email)
- [ ] Implement Gemini multi-turn payload builder
- [ ] Implement generate_response
- [ ] Implement generate_thread_title
- [ ] **Tests:**
  - [ ] Contact resolution from metadata tests
  - [ ] Meeting context gathering tests (email match, limit 10, ordering)
  - [ ] Gemini payload builder tests (multi-turn format)
  - [ ] generate_response tests with mocked Gemini API
  - [ ] generate_thread_title tests

### Step 6: Basic UI
- [ ] Create chat bubble component
- [ ] Create chat panel layout
- [ ] Create thread list view
- [ ] Create message list view
- [ ] Create message input with @mention detection
- [ ] Wire up to Chat context
- [ ] **Tests:**
  - [ ] LiveView mount tests
  - [ ] Thread list rendering tests
  - [ ] Message list rendering tests
  - [ ] Send message event tests

### Step 7: Contact Mention UX
- [ ] Create mention dropdown component
- [ ] Wire up search to Contacts.search_contacts
- [ ] Handle contact selection → store in metadata
- [ ] Add keyboard navigation
- [ ] **Tests:**
  - [ ] Mention trigger tests (@ detection)
  - [ ] Dropdown search tests
  - [ ] Contact selection tests (metadata populated correctly)
  - [ ] Keyboard navigation tests

### Step 8: Polish & Integration Testing
- [ ] Add loading states (typing indicator)
- [ ] Add error handling (API failures, no meetings found)
- [ ] **Tests:**
  - [ ] Error state rendering tests
  - [ ] Loading state tests
  - [ ] End-to-end flow tests (create thread → send message → receive response)

---

## Data Flow

```
User creates new thread
         │
         ▼
┌─────────────────────────────────┐
│  Empty thread created           │
│  User types message with @John  │
└─────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│  @ triggers contact dropdown    │
│  User selects "John Doe"        │
│  Contact stored in metadata     │
└─────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│  User clicks Send               │
│  Resolve contact from metadata  │
└─────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│  Gather context:                │
│  - Fresh CRM data for contact   │
│  - Last 10 meetings w/ contact  │
│  - All messages in this thread  │
└─────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│  Build Gemini multi-turn payload│
│  Call Gemini API                │
└─────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│  Save user message + metadata   │
│  Save assistant message +       │
│  meeting_refs in metadata       │
└─────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│  Display in chat UI             │
│  Meeting refs → clickable links │
└─────────────────────────────────┘
```

---

## Meeting Matching Strategy

Match meetings to a contact using calendar attendee emails:

```elixir
def find_meetings_for_contact(user, contact) do
  # 1. Get all user's meetings with calendar_events preloaded
  # 2. Filter where calendar_event.attendees contains contact.email
  # 3. Order by recorded_at DESC
  # 4. Limit 10

  from(m in Meeting,
    join: ce in assoc(m, :calendar_event),
    where: ce.user_id == ^user.id,
    where: fragment("? @> ?", ce.attendees, ^[%{email: contact.email}]),
    order_by: [desc: m.recorded_at],
    limit: 10,
    preload: [:meeting_transcript, :meeting_participants]
  )
  |> Repo.all()
end
```

---

## Technical Considerations

### Token Limits
- Gemini has context limits (~128k tokens for gemini-2.0-flash)
- Context includes: system prompt + CRM data + 10 meetings + thread messages
- Thread messages are typically small compared to meeting transcripts
- Strategy: If total context exceeds limit, truncate older meeting transcripts first

### Performance
- Contact search should be fast (indexed on user_id, email, name)
- CRM data fetch is external API call - show loading state
- Consider caching CRM data briefly (5 min TTL)

### Privacy
- Threads are strictly private per user
- No sharing functionality
- Ownership check on all thread/message operations

---

## Open Questions (Resolved)

| Question | Decision |
|----------|----------|
| Thread title generation | Gemini generates title after first interaction |
| Message editing | Not for v1 |
| Thread archiving | Simple delete for v1 |
| Offline handling | Show error, allow retry |
| Rate limiting | Not for v1 |

---

## Future Enhancements

See also: `IMPROVEMENTS.md`

1. **Vector embeddings** - Semantic search across all meetings instead of last 10
2. **CRM IDs in contacts** - Store salesforce_id, hubspot_id for direct linking
3. **Background contact sync** - Periodic sync from CRMs
4. **Multi-contact threads** - Ask about multiple people in one thread
5. **Suggested questions** - AI suggests follow-up questions
6. **Chat history search** - Search across all threads
7. **Export chat** - Download conversation as PDF/markdown
